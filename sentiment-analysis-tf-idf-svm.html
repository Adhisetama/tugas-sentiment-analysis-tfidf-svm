<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TF-IDF Vectorizer</title>
</head>
<!-- <link rel="stylesheet" href="./css/reset.css"> -->
<style>
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 3px;
        /* border: 1px solid red; */
    }
    table {
      border-collapse: collapse;
    }
    th, td {
      border: 1px solid black;
      text-align: left;
    }

    /* custom CSS */
    #main-container {
        width: auto;
        padding: 50px;
        margin: 0;
    }
    #form-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr;
        /* border: 2px solid black; */
    }
    #vocabulary-container {
        display: grid;
        grid-template-columns: 3fr 1fr;
        grid-template-rows: 1fr 30px;
    }
    #add-data-container table tr td * {
        width: 100%;
    }
    #add-data-container > button {
        padding: 5px 10px;
    }

    #vectorize-document {
        grid-column: span 2;
    }

    /* #vector-container {
        display: grid;
        grid-template-rows: 1fr 1fr;
        grid-template-columns: auto auto ;
    } */

    #document-vector-container, #idf-vectorizer-container, #svm-container {
        display: flex;
        width: 100%;
        flex-wrap: wrap;
    }

    #svm-metrics {
        display: grid;
        grid-template-columns: max-content 1fr;
        grid-template-rows: min-content 1fr;
        /* border: 2px solid black; */
    }

    .initiallyHidden {
        opacity: 1;
    }

    div, form {
        border: 1px solid red;
    }

</style>
<body>
    <div id="main-container">

        <h2>TF-IDF Vectorizer</h2>

        <div id="form-container">
            <div id="upload-csv-container">
                <h3>upload data</h3>
                <p>format: csv</p>
                <p>example:</p>
                <table style="width: 100%;">
                    <tr><th>document (string)</th><th>class (1 or -1)</th><td rowspan="4" style="font-family: monospace;">
                    document, class<br>
                    this is a sample document, 1<br>
                    this also a sample document, -1<br>
                    make sure the data is already preprocessed, 1<br>
                    string defined without a quotation mark, 1<br>
                    the csv file should look almost like this, -1
                    </td></tr>
                    <tr><td>"this is sample document"</td><td>1</td></tr>
                    <tr><td>"this also a sample document"</td><td>-1</td></tr>
                    <tr><td>...</td><td>...</td></tr>
                </table>
                <form action="">
                    <input type="file" id="csv" accept=".csv">
                </form>
            </div>
            <div id="add-data-container">
                <h3>or insert data manually</h3>
                <table style="width: 100%;">
                    <thead>
                        <tr><th>document</th><th>class</th><th></th></tr>
                    </thead>
                    <tbody id="add-data-table">
                        <tr>
                            <td><input type="text" placeholder="type sentence here"></td>
                            <td><input type="number" min="-1" max="1" step="2" value="1"></td>
                            <td><button>üóëÔ∏è</button></td>
                        </tr>
                    </tbody>
                </table>
                <button id="add-document">+</button>
                <button id="submit-document">Submit</button>
            </div>
        </div>

        <div id="vocabulary-container" class="initiallyHidden">
            <form id="term-count-container">
                <h3>Œ£ words</h3>
                <table>
                    <thead><tr><th>term</th><th>count</th><th>select as vocab</th></tr></thead>
                    <tbody id="bag-of-words">
                        <!-- <tr>
                            <td>bjir</td>
                            <td>10</td>
                            <td><input type="checkbox"></td>
                        </tr> -->
                    </tbody>
                </table>
            </form>
            <div id="term-container">
                <h3>define vocabulary:</h3>
                <p style="font-family: monospace;" id="terms"></p>
            </div>
            <button id="vectorize-document"><b>Vectorize Documents</b></button>
        </div>

        <div id="document-vector-container" class="initiallyHidden">
            <table style="flex: 2">
                <thead id="thead-vector">
                    <tr>
                        <th rowspan="2">document</th>
                        <th colspan="3">vector x<sub>i</sub></th>
                        <th rowspan="2">class y<sub>i</sub></th>
                    </tr>
                    <tr>
                        <th>tes</th>
                        <th>tes</th>
                        <th>tes</th>
                    </tr>
                </thead>
                <tbody id="tbody-vector">
                    <tr>
                        <td>bjir azka hijau ...</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>-1</td>
                    </tr>
                </tbody>
            </table>
            <div style="flex: 1">
                <h3>2D space representation</h3>
                <canvas id="vector-canvas"></canvas>
                <br>
                <form action="">
                    <label for="vector-x">sumbu-x</label>
                    <select name="vector-x" id="vector-x" value="0"></select>
                    <label for="vector-y">sumbu-y</label>
                    <select name="vector-y" id="vector-y" value="0"></select>
                </form>
            </div>
            <button style="width: 100%;" id="download-dataset-csv">Download dataset as CSV</button>
        </div>

        <div id="idf-vectorizer-container" class="initiallyHidden">
            <table style="flex: 0;">
                <thead><tr><th>term</th><th>IDF</th></tr></thead>
                <tbody id="table-idf">
                    <tr><td>term1</td><td>idf1</td></tr>
                </tbody>
            </table>
            <div id="idf-vectorizer" style="flex: 1;">
                <h3>vectorize a document</h3>
                <textarea id="textarea-vectorizer" rows="3" style="width: 100%;"></textarea>
                <button id="bakso-bakar">convert to vector</button>
                <table style="display: block;">
                    <tr>
                        <th rowspan="2">vector</th>
                        <th colspan="2" id="balsem-geliga">feature (terms)</th>
                    </tr>
                    <tr id="rolled-oat">
                        <th>tes</th>
                        <th>tes</th>
                    </tr>
                    <tr id="bakso1"><th>TF</th><td>2.642</td><td>1.002</td></tr>
                    <tr id="bakso2"><th>TF-IDF</th><td>2.642</td><td>1.002</td></tr>
                </table>
            </div>
            <button style="width: 100%;" id="download-idf-json">Download IDF as JSON</button>
        </div>

        <div id="svm-container" class="initiallyHidden">
            <div id="svm-display" style="flex: 0;">
                <canvas id="svm-canvas"></canvas>
                <br>
                <div>
                    <label for="svm-x">sumbu-x</label>
                    <select name="svm-x" id="svm-x" value="0"></select>
                    <label for="svm-y">sumbu-y</label>
                    <select name="svm-y" id="svm-y" value="0"></select>
                    <button name="optimize-smo" id="optimize-smo">optimize (SMO)</button>
                </div>
                <!-- contains: iteration n; ai, as, before after. w and b before after -->
                <h4 id="svm-iteration-n">Iteration 0</h4>
                <p id="svm-selected-i-s">selected {r, s} = {1, 2}</p>
                <table style="width: 100%;">
                    <thead>
                        <tr>
                            <th rowspan="2">variable</th><th colspan="2">value</th>
                        </tr>
                        <tr><th>old</th><th>new</th></tr>
                    </thead>
                    <tbody id="svm-iteration-detail">
                        <tr>
                            <td>Œ±<sub>r</sub></td>
                            <td id="svm-iter-ar-old"></td>
                            <td id="svm-iter-ar-new"></td>
                        </tr>
                        <tr>
                            <td>Œ±<sub>s</sub></td>
                            <td id="svm-iter-as-old"></td>
                            <td id="svm-iter-as-new"></td>
                        </tr>
                        <tr>
                            <td><b>w</b></td>
                            <td id="svm-iter-w-old"></td>
                            <td id="svm-iter-w-new"></td>
                        </tr>
                        <tr>
                            <td>b</td>
                            <td id="svm-iter-b-old"></td>
                            <td id="svm-iter-b-new"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="svm-metrics" style="flex: 1;">
                <div id="svm-confusion-matrix">
                    <h5>Confusion Matrix</h5>
                    <table>
                        <tr>
                            <td colspan="2" rowspan="2"></td>
                            <td colspan="2">predicted</td>
                        </tr>
                        <tr>
                            <td>+</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td rowspan="2">actual</td>
                            <td>+</td>
                            <td id="svm-conf-tp">TP</td>
                            <td id="svm-conf-fn">FN</td>
                        </tr>
                        <tr>
                            <td>-</td>
                            <td id="svm-conf-fp">FP</td>
                            <td id="svm-conf-tn">TN</td>
                        </tr>
                    </table>
                </div>
                <form id="svm-metrics-form">
                    <h5>Evaluation Metrics</h5>
                    <table style="width: 100%;">
                        <tr>
                            <td>Metrics :</td>
                            <td>Accuracy</td>
                            <td>Precision</td>
                            <td>Recall</td>
                            <td>F<sub>1</sub> Score</td>
                            <td>Specificity</td>
                            <td>Matthew's Correlation Coefficient (MCC)</td>
                        </tr>
                        <tr>
                            <td>Value :</td>
                            <td id="svm-metrics-accuracy"></td>
                            <td id="svm-metrics-precision"></td>
                            <td id="svm-metrics-recall"></td>
                            <td id="svm-metrics-F1_score"></td>
                            <td id="svm-metrics-specificity"></td>
                            <td id="svm-metrics-MCC"></td>
                        </tr>
                        <tr>
                            <td>View Graph :</td>
                            <td><input type="radio" name="svm-metrics" value="accuracy" checked></td>
                            <td><input type="radio" name="svm-metrics" value="precision"></td>
                            <td><input type="radio" name="svm-metrics" value="recall"></td>
                            <td><input type="radio" name="svm-metrics" value="F1_score"></td>
                            <td><input type="radio" name="svm-metrics" value="specificity"></td>
                            <td><input type="radio" name="svm-metrics" value="MCC"></td>
                        </tr>
                    </table>
                </form>
                <div style="grid-column: span 2;">
                    <canvas style="width: 100%;" id="svm-chart"></canvas>
                    <h4>Try the model</h4>
                    <p>predict the classification of document/sentence with current SVM model's weight and bias</p>
                    <textarea style="width: 100%;" rows="5" id="predict-model-textarea"></textarea>
                    <button id="predict-model-button">predict</button>
                    <table id="predict-model-table"></table>
                </div>
            </div>
        </div>

    </div>

    <!-- get documents -->
    <script>
        const Data = {
            documents: [],
            classes: [],
            vectors: []
        }

        // handle csv upload
        document.getElementById("csv").addEventListener('change', event => {
            Data.documents.length = 0
            Data.classes.length = 0
            const file = event.target.files[0]
            if (file) {
                const reader = new FileReader()
                reader.onload = e => {
                    const lines = e.target.result.split('\n')
                    for (const line of lines) {
                        let [document, classes] = line.split(',')
                        document = document.trim()
                        classes = parseInt(classes)
                        if (classes === -1 || classes === 1) {
                            Data.documents.push(document)
                            Data.classes.push(classes)
                            console.log("data parsed: ", [document, classes])
                        }
                    }
                    document.dispatchEvent(new Event('documentsHasBeenInserted'))
                }
                reader.readAsText(file)
            }
        })

        // handle insert data manually
        document.getElementById("add-document").addEventListener("click", event => {
            const tr = document.createElement("tr")
            tr.innerHTML =
            `   <td><input type="text" placeholder="type sentence here"></td>
                <td><input type="number" min="-1" max="1" step="2" value="1"></td>
                <td><button>üóëÔ∏è</button></td>`
            document.getElementById("add-data-table").appendChild(tr)
        })
        document.getElementById("submit-document").addEventListener("click", event => {
            Data.documents.length = 0
            Data.classes.length = 0
            document.querySelectorAll("#add-data-table tr").forEach((row, i) => {
                // if (i === 0) return
                Data.documents.push(row.children[0].firstChild.value.trim())
                Data.classes.push(row.children[1].firstChild.value)
            })
            document.dispatchEvent(new Event('documentsHasBeenInserted'))
        })


    </script>

    <!-- document has been inserted -->
    <script>
        /**
         * WHAT TO DO:
         * 1. training
         * buat code untuk ngitung TF setiap dokumen
         * buat code untuk ngitung IDF dari semua dokumen
         * simpan tabel IDF
         * 
         * 2. parsing (dokumen --> feature vector)
         * hitung TF dokumen tsb
         * dari tabel IDF, kalikan TF dengan IDF
         * didapat feature vektor dgn dimensi tergantung banyaknya
         * term dalam vocab
         * 
         * 
         * ASUMSI:
         * - isi setiap dokumen sudah di preprocessing (stemming, dll)
         * - sudah didapatkan vocab
         * 
         * NOTES:
         * - rumus idf yang dipakai: idf(t) = ln(N / df(t))
         * - rumus tf yang dipakai: tf(t,d) = f(t,d) / sum(f(t_i,d))
         */

        class TFIDF_Vectorizer {

        /**
         */
        constructor() {
            this.trainDocuments = []
            this.vocabulary = []
            this.idf = []
        }


        /**
         * 
         * @param {string[]} vocabulary array of terms
         */
        setVocabulary(vocabulary) {
            this.vocabulary = vocabulary
            this.idf.length = vocabulary.length
        }

        /**
         * 
         * @param  {...TFIDF_Document} trainDocument 
         */
        insertTrainDocuments(...trainDocument) {
            this.trainDocuments.push(...trainDocument)
        }

        calculateIDF() {
            this.vocabulary.forEach((term, term_index) =>  {
                // hitung df untuk setiap term
                let df = 0
                this.trainDocuments.forEach(trainDocument => {
                    df += trainDocument.words.includes(term) ? 1 : 0
                })
                // hitung idf berdasar df
                // console.log(df)
                this.idf[term_index] = Math.log(this.trainDocuments.length / df)
            })
        }

        /**
         * 
         * @param {TFIDF_Document} document 
         * @returns {number[]} representasi vektor dari dokumen dgn TF-IDF
         */
        vectorizeDocument(document) {
            const vector = [...this.idf]
            document.calculateTF(this.vocabulary).forEach((tf, index) => {
                vector[index] *= tf
            })
            return vector
        }

        }

        class TFIDF_Document {

        /**
         * @param {string[]} tokenizedWords 
         */
        constructor(tokenizedWords) {
            this.words = tokenizedWords

            // hitung semua okurensi term (bag of words)
            this.bagOfWords = {}
            for (const word of this.words) {
                if (word in this.bagOfWords){
                    this.bagOfWords[word] += 1
                } else {
                    this.bagOfWords[word] = 1
                }
            }
        }

        /**
         * @param {string[]} vocabulary 
         * @returns {Number[]} vektor dari TF
         */
        calculateTF(vocabulary) {
            const tf = Array(vocabulary.length)
            vocabulary.forEach((term, term_index) => {
                // rumus tf tanpa log
                tf[term_index] = term in this.bagOfWords ? this.bagOfWords[term] / this.words.length : 0
            })
            return tf
        }

        }

        /**
        * contoh cara pakai:
        * 
        * // definisikan term-term di vocabulary
        * const vocabulary <-- ["term1", "term2", ...]
        * const Vectorizer = new TFIDF_Vectorizer(vocabulary)
        * 
        * // load dataset
        * foreach d in dataset:
        *     const tokenizedWords = parseTokenizedWord(d)
        *     const document = new TFIDF_Document(tokenizedWords)
        *     Vectorizer.insertTrainDocuments(document)
        * 
        * // train
        * Vectorizer.calculateIDF()
        * 
        * // convert to feature vector
        * foreach d in dataset:
        *      X_train.push(Vectorizer.vectorizeDocument(d))
        *      Y_train.push(d.class)
        * 
        * // masukkan X_train Y_train ke dataset
        * // klasifikasikan dengan SVM
        */
    </script>
    <script>
        const Documents = []    // TFIDF_Documents[]
        const bagOfWords = {}   // Object{
                                //    word:string => count:int
                                //  }
        const vocabulary = []   // string[]

        // handle changes of page
        document.addEventListener('documentsHasBeenInserted', e => {
            document.getElementById("vocabulary-container").style.opacity = '1'
            // reset previous input
            Documents.length = 0
            vocabulary.length = 0
            for (const word in bagOfWords) delete bagOfWords[word]
            Data.documents.forEach(e => Documents.push(new TFIDF_Document(e.split(' '))))
            const tbody = document.getElementById("bag-of-words")
            const terms = document.getElementById("terms")
            tbody.innerHTML = ""
            terms.innerHTML = ""

            // hitung total kata muncul
            Documents.forEach(d => {
                for (const word in d.bagOfWords) {
                    if (bagOfWords.hasOwnProperty(word))
                        bagOfWords[word] += d.bagOfWords[word]
                    else
                        bagOfWords[word] = d.bagOfWords[word]
                }
            })

            // tampilkan di tabel, kalo di klik checkbox nanti tabel satunya berubah
            // (dah gausah dibaca, aku jg pusing baca ini)
            for (const word in bagOfWords) {
                const tr = document.createElement("tr")
                tr.innerHTML = `<td>${word}</td><td>${bagOfWords[word]}</td><td><input type="checkbox" name="${word}"></td>`
                tbody.appendChild(tr)
            }

            // listen untuk checkbox
            document.getElementById("term-count-container").addEventListener("change", event => {
                // scan semua checkbox, mana yg dicheck
                vocabulary.length = 0
                for (const element of event.currentTarget.elements) {
                    if (element.checked) {
                        vocabulary.push(element.name)
                    }
                }
                terms.innerText = JSON.stringify(vocabulary)
            })
        })

        // vectorize document
        const Vectorizer = new TFIDF_Vectorizer()
        document.getElementById("vectorize-document").addEventListener("click", event => {
            Vectorizer.trainDocuments.length = 0
            Vectorizer.insertTrainDocuments(...Documents)
            Vectorizer.setVocabulary(vocabulary)
            Vectorizer.calculateIDF()
            document.dispatchEvent(new Event("documentsHasBeenVectorized"))
        })

    
    </script>
    
    <!-- document has been vectorized -->
    <script>
        /**
         * DOCUMENTATION:
         * 
         * 
         * // 1.| deklarasi class
         * const canvas = new Canvas(e, options); // e -> html canvas element, 
         *                                        // options -> object, property: height, width, padding
         *                                        // parameter 'options' optional, ada default value nya
         * 
         * // 2.| untuk gambar titik:
         * p = [[p1x, p1y], [p2x, p2y], ... [pnx, pny]]
         * colors = ["color1", "color2", ... "colorn"]
         * canvas.drawPoints(p, colors)
         * 
         * 
         * // 3.| untuk  gambar garis:
         * canvas.drawLine(w, b) // garis direpresentasikan dengan weight vektor w dan bias b
         * 
         * // 4.| untuk gambar axis:
         * canvas.drawAxis()
         * 
         * // note: untuk 3. & 4.:
         *      - sebelumnya harus .drawPoints() dulu untuk tentuin skala konversi koordinat
         *      - jika garisnya diluar scope canvas, ngga akan kegambar
         * 
         * // 5.| untuk clear canvas
         * canvas.clear()
         * 
         * // note: canvas ini hanya support vektor 2d. parameter p di .drawPoints() dan w di .drawLine() harus 2 dimensi
         * 
         */

        class Canvas
        {

            /**
             * 
             * @param {HTMLElement} canvasElement html element: <canvas>
             * @param {Object} options 
             * @param {number} options.width panjang dari canvas
             * @param {number} options.height tinggi dari canvas
             * @param {number} options.padding padding dari canvas
             */
            constructor(canvasElement, options={}) {
                this.canvas = canvasElement
                this.canvas.style.border = "1px solid black"
                this.canvas.style.width = options.width !== undefined ? options.width + "px" : "500px"
                this.canvas.style.height = options.height !== undefined ? options.height + "px" : "500px"
                this.canvas.setAttribute("width", options.width !== undefined ? options.width + "px" : "500px")
                this.canvas.setAttribute("height", options.height !== undefined ? options.height + "px" : "500px")
                this.padding = options.padding ? options.padding : 20

                this.ctx = this.canvas.getContext('2d')
            }

            drawPoints(points, colors) {

                // get max & min X and Y
                this.min_X = points[0][0]
                this.max_X = points[0][0]
                this.min_Y = points[0][1]
                this.max_Y = points[0][1]

                for (const p of points) {
                    if (p[0] < this.min_X)
                        this.min_X = p[0]
                    if (p[0] > this.max_X)
                        this.max_X = p[0]
                    if (p[1] < this.min_Y)
                        this.min_Y = p[1]
                    if (p[1] > this.max_Y)
                        this.max_Y = p[1]
                }
                
                this.len_X = this.max_X - this.min_X
                this.len_Y = this.max_Y - this.min_Y

                console.log(colors)
                points
                    .map(p => this.convertToVirtualCoordinate(p))
                    .forEach((p, i) => {
                        if (colors[i] !== undefined) {
                            this.ctx.fillStyle = colors[i]
                        } else {
                            this.ctx.fillStyle = "darkgray"
                        }
                        this.ctx.fillRect(p[0], p[1], 10, 10)
                    })


            }

            getVirtualWidth() {
                return this.canvas.offsetWidth - 2*this.padding
            }

            getVirtualHeight() {
                return this.canvas.offsetHeight - 2*this.padding
            }

            convertToVirtualCoordinate(p) {
                // virtual_coord = original_coord - min_original_coord * virtual_length / original_coord_length + padding
                return [
                    (p[0] - this.min_X) * (this.getVirtualWidth() / this.len_X) + this.padding,
                    // untuk y, maka y <-- canvas_height - y
                    this.canvas.offsetHeight - ((p[1] - this.min_Y) * (this.getVirtualHeight() / this.len_Y) + this.padding)
                ]

            }

            drawLine(w, b) {
                const FromTo = this.convertVectorToLine(w, b)
                console.log(FromTo)
                if (FromTo.length === 0) return
                this.ctx.beginPath()
                this.ctx.strokeStyle = "black"
                this.ctx.fillStyle = "black"
                this.ctx.moveTo(...FromTo[0])
                this.ctx.lineTo(...FromTo[1])
                this.ctx.stroke()
            }

            /**
             * fungsi ini menerjemahkan garis yang awalnya barbentuk vektor w dan bias b
             * menjadi dua titik koordinat"from" dan "to" dalam kanvas
             * @param {number[]} w weight atau vektor dari garis
             * @param {number} b bias dari garis
             * @returns 
             */
            convertVectorToLine(w, b) {
                // cek w
                if (w.some(e => e === undefined) || w[1] === 0) return []

                // equation y = mx + c
                const m = -w[0]/w[1]
                const c = -b/w[1]
                const line_y = x => m*x + c
                const line_x = y => (y - c) / m

                // calculate from and to, cek semua titik kotak
                let FromTo = []
                
                // 1. apabila garis bertubrukan dengan sisi kanan:
                if (this.min_Y < line_y(this.max_X) < this.max_Y)
                    FromTo.push([this.max_X, line_y(this.max_X)])

                // 2. apabila garis bertubrukan dengan sisi kiri:
                if (this.min_Y < line_y(this.min_X) < this.max_Y)
                    FromTo.push([this.min_X, line_y(this.min_X)])

                // 3. apabila garis bertubrukan dengan sisi atas:
                if (this.min_X < line_x(this.max_Y) < this.max_X)
                    FromTo.push([line_x(this.max_Y), this.max_Y])

                // 4. apabila garis bertubrukan dengan sisi bawah:
                if (this.min_X < line_x(this.min_Y) < this.max_X)
                    FromTo.push([line_x(this.min_Y), this.min_Y])

                // kalo bener harusnya FromTo berisi 2 ato 0 elemen
                return FromTo.map(p => this.convertToVirtualCoordinate(p))
            }

            drawAxis() {
                // check if 0,0 / axis line inside canvas
                const O = this.convertToVirtualCoordinate([0,0])
                this.ctx.strokeStyle = "gray"
                this.ctx.fillStyle = "gray"
                if (this.padding < O[0] < this.getVirtualWidth()) {
                    this.ctx.beginPath()
                    this.ctx.moveTo(O[0], this.getVirtualHeight() + 2*this.padding)
                    this.ctx.lineTo(O[0], 0)
                    this.ctx.stroke()
                }
                if (this.padding < O[1] < this.getVirtualHeight()) {
                    this.ctx.beginPath()
                    this.ctx.moveTo(0, O[1])
                    this.ctx.lineTo(this.getVirtualWidth() + 2*this.padding, O[1])
                    this.ctx.stroke()
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight)
            }

        }
    </script>
    <script>
        /**
         * 
         * @param {string} content content of the file that will be downloaded
         * @param {string} filename filename of the file that will be downloaded
         */
        function downloadTextFile(content, filename) {
            var blob = new Blob([content], { type: 'text/plain' })

            var a = document.createElement('a')
            a.href = window.URL.createObjectURL(blob);
            a.download = filename

            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
        }
    </script>
    <script>
        document.addEventListener("documentsHasBeenVectorized", event => {
            document.getElementById("document-vector-container").style.opacity = '1'
            document.getElementById("idf-vectorizer-container").style.opacity = '1'
            // INISIASI TABEL
            // thead
            {
                const [sego, goreng] = document.getElementById("thead-vector").children
                sego.children[1].setAttribute("colspan", `${Vectorizer.vocabulary.length}`)
                goreng.innerHTML = ""
                Vectorizer.vocabulary.forEach(term => {
                    const th = document.createElement("th")
                    th.innerText = `"${term}"`
                    goreng.appendChild(th)
                })
            }
            // tbody
            {
                const tbody = document.getElementById("tbody-vector")
                tbody.innerHTML = ""
                let i = 0
                for (const d of Vectorizer.trainDocuments) {
                    const docString = d.words.join(" ")
                    const docVector = Vectorizer.vectorizeDocument(d)
                    Data.vectors.push(docVector)
                    if (++i > 20) continue
                    const tr = document.createElement("tr")
                    // note: vv print document as string tp batasin sampe 25 huruf
                    let tr_innerHTML = `<td${docString.length > 25 ? ` title="${docString}">"${docString.substring(0, 25)}..."` : `>"${docString}"`}</td>`
                    docVector.forEach(x => tr_innerHTML += `<td>${x.toFixed(7)}</td>`)
                    tr_innerHTML += `<td>${Data.classes[i]}</td>`
                    tr.innerHTML = tr_innerHTML
                    tbody.appendChild(tr)
                }
            }
            
            // INISIASI CANVAS
            {
                const vectorCanvas = document.getElementById("vector-canvas")
                const canvas = new Canvas(vectorCanvas, {
                    width: 300,
                    height: 300,
                    padding: 0
                })
                const selectX = document.getElementById("vector-x")
                const selectY = document.getElementById("vector-y")
                let select_innerHTML = ""
                Vectorizer.vocabulary.forEach((term, index) => {
                    select_innerHTML += `<option value="${index}">${term}</option>`
                })
                selectX.innerHTML = selectY.innerHTML = select_innerHTML
                const redrawCanvas = (axisX, axisY) => {
                    canvas.clear()
                    canvas.drawPoints(
                        Data.vectors.map(p => [p[axisX], p[axisY]]),
                        Data.classes.map(c => c == 1 ? "blue" : "red")
                    )
                    canvas.drawAxis()
                }
                selectX.addEventListener("change", e => redrawCanvas(selectX.value, selectY.value))
                selectY.addEventListener("change", e => redrawCanvas(selectX.value, selectY.value))
            }
                    
            // INISIASI VECTORIZER:
            {
                document.getElementById("balsem-geliga")
                    .setAttribute("colspan", `${Vectorizer.vocabulary.length}`)
                const nggatau = document.getElementById("rolled-oat")
                nggatau.innerHTML = ""
                document.getElementById("bakso1").innerHTML = "<th>TF</th>" + "<td></td>".repeat(Vectorizer.vocabulary.length)
                document.getElementById("bakso2").innerHTML = "<th>TF-IDF</th>" + "<td></td>".repeat(Vectorizer.vocabulary.length)
                Vectorizer.vocabulary.forEach(term => {
                    const th = document.createElement("th")
                    th.innerText = `"${term}"`
                    nggatau.appendChild(th)
                })
                document.getElementById("bakso-bakar").addEventListener("click", e => {
                    // yah intinya gitu.
                    const d = new TFIDF_Document(document.getElementById("textarea-vectorizer").value.trim().split(" "))
                    let tf_innerHTML = "<th>TF</th>"
                    let tfidf_innerHTML = "<th>TF-IDF</th>"
                    d.calculateTF(Vectorizer.vocabulary).forEach(tf => {
                        tf_innerHTML += `<td>${tf.toFixed(7)}</td>`
                    })
                    Vectorizer.vectorizeDocument(d).forEach(tfidf => {
                        tfidf_innerHTML += `<td>${tfidf.toFixed(7)}</td>`
                    })
                    document.getElementById("bakso1").innerHTML = tf_innerHTML
                    document.getElementById("bakso2").innerHTML = tfidf_innerHTML
                })
            }
        
            // INISIASI TABEL IDF
            {
                const tableIDF = document.getElementById("table-idf")
                tableIDF.innerHTML = ""
                Vectorizer.vocabulary.forEach((term, index) => {
                    tableIDF.innerHTML += `<tr><th>"${term}"</th><td>${Vectorizer.idf[index].toFixed(7)}</td></tr>`
                })
            }

            // INISIASI BUTTON DOWNLOAD
            {
                document.getElementById("download-dataset-csv").addEventListener("click", event => {
                    // parse dataset menjadi csv
                    let datasetCSV = `${Vectorizer.vocabulary.join(",")},class\n`
                    Data.vectors.forEach((vector, index) => {
                        datasetCSV += `${vector.join(",")},${Data.classes[index]}\n`
                    })
                    downloadTextFile(datasetCSV, "dataset.csv")
                })
                document.getElementById("download-idf-json").addEventListener("click", event => {
                    let idfJSON = {}
                    Vectorizer.vocabulary.forEach((term, index) => {
                        idfJSON[term] = Vectorizer.idf[index]
                    })
                    downloadTextFile(JSON.stringify(idfJSON, null, 2), "idf.json")
                })
            }

        })

    </script>

    <!-- svm -->
    <script>
        // TODO:
        // buat code yg accept train parameter: 
        //      X berisi xi:vektor
        //      Y berisi yi:class
        // return:
        //      W:vektor
        //      b:scalar
        // dengan algoritma SVM

        /**
         * DOCUMENTATION
         * 
         * // 1.| inisialisasi class
         * const svm = new SVM(x_train, y_train)
         * 
         * // 2.| iterasi optimisasi (lakukan berulang")
         * svm.iterate()
         * 
         * // 3.| hitung weight & bias
         * let w = svm.getWeight()
         * let b = svm.getBias()
         * 
         */

        class SVM {

        /**
         * inisiasi SVM, (belum ada parameter checking).
         * 
         * @param {number[][]} X_train array berisi vektor x_i dgn dimensi sama
         * @param {number[]} Y_train array berisi class y_i (1 atau -1)
         * @param {Object} options
         * @param {number} options.C hyperparameter C 
         * @param {number} options.E hyperparameter epsilon (error tolerance)
         */
        constructor(X_train, Y_train, options={}) {
            // input parameter
            this.X = X_train // array berisi vektor x_i
            this.Y = Y_train // array berisi class  y_i
                    
            // variabel untuk perhitungan SVM
            this.N = this.X.length       // banyak data training
            this.P = this.X[0].length    // banyak fitur/dimensi data
            this.alpha = Array(this.N).fill(0)                   // parameter alpha di lagrange multiplier
            this.C = options.C !== undefined ? options.C : 10    // hyperparameter C. default=10
            this.E = options.E !== undefined ? options.E : 0.01  // hyperparameter epsilon (error tolerance). default=0.01

            // optimized value
            this.w = Array(this.N).fill(0)
            this.b = 0
        }

        /**
         * memprediksi class Y berdasar feature vector X yang diberi dgn w dan b
         * @param {number[]} X_test vektor X untuk test. dimensi harus sama dengan dataset
         * @returns {1|-1} prediksi class (1 atau -1)
         */
        predict(X_test) {
            // decision function: sign of (w . x + b)
            return this.Math.dot(X_test, this.w) + this.b > 0 ? 1 : -1
        }

        /**
         * satu kali iterasi optimisasi SMO (sequential minimal optimization)
         * akan mengupdate 2 value alpha yg dipilih secara random
         * @returns {Object} detail dari iterasi (r,s yang dipilih; update a_r & a_s)
         */
        iterate() {
            // pick 2 random index
            let [r, s] = this.Math.pickTwo(this.N)

            // assign variable (biar ga dikit" thas this thas this)
            const [a_r, a_s] = [this.alpha[r], this.alpha[s]]
            const [x_r, x_s] = [this.X[r], this.X[s]]
            const [y_r, y_s] = [this.Y[r], this.Y[s]]

            // definisikan batas range untuk a_r
            let range = null
            const gamma = this.calcGamma(r, s)
            if (y_r === y_s) {
            // kasus 1. untuk y_r == y_s (titik x_r & x_s dalam class yg sama)
                range = [
                    Math.max(0, -y_r*(y_s*this.C - gamma)),
                    Math.min(this.C, y_r*gamma)
                ]
            } else {
            // kasus 2. untuk y_r != y_s (titik x_r & x_s dalam class yg berbeda)
                range = [
                    Math.max(0, y_r*gamma),
                    Math.min(this.C, -y_r*(y_s*this.C - gamma))
                ]
            }

            // cari parameter a,b,c dalam persamaan kuadrat f(a_r)
            // penjelasan:
            //      dari persamaan asli, ambil a_r & a_s sebagai variabel dan
            //      anggap lainnya konstanta, tapi substitusikan a_s = (gamma - a_r*y_r)/y_s
            //      dan didapetlah persamaan kuadrat yg variabelnya cuma a_r ¬Ø\_(„ÉÑ)_/¬Ø
            const beta = this.calcBeta(r, s)
            const a = 0.5*(this.Math.dot(x_r, x_r) + this.Math.dot(x_s, x_s) - 2*this.Math.dot(x_r, x_s))
            const b = gamma*y_r*(this.Math.dot(x_r, x_s) - this.Math.dot(x_s, x_s))
                    + y_r*this.Math.dot(
                        this.Math.eachElements(x_r, x_s, (x_r_i, x_s_i, i) => x_r_i - x_s_i),
                        beta
                        )
                    + y_r*y_s - 1
            const c = gamma*(
                        0.5*gamma*this.Math.dot(x_s, x_s)
                        + this.Math.dot(x_s, beta)
                        - y_s
                        )
            // ^^ semoga code nya gaada yg salah plis

            // x di kondisi critical: f'(x) = ax+b = 0
            // x = -b/2a
            let a_r_new = -b / (2*a)

            // batasi value x_r_new di range yg telah terdefinisi
            a_r_new = Math.min(Math.max(a_r_new, range[0]), range[1])

            // inget constraint a_r*y_r + a_s*y_s = gamma
            let a_s_new = (gamma - a_r_new*y_r) /  y_s

            // update value di svm
            this.alpha[r] = a_r_new
            this.alpha[s] = a_s_new

            // return info dari iterasi (untuk debug)
            return {
                "r": r,
                "s": s,
                "a_r_old": a_r,
                "a_r_new": a_r_new,
                "a_s_old": a_s,
                "a_s_new": a_s_new,
            }
            
        }

        /**
         * confusion matrix:
         *            predicted:
         *              +    -
         * actual: +  [[TP, FN],
         *         -   [FP, TN]]
         * @param {number[][]} X_test array of vectors
         * @param {number[]} Y_test array of class of vectors
         * @returns {number[2][2]} confusion matrix
         */
        getConfusionMatrix(X_test, Y_test) {
            const Y_pred = X_test.map(X => this.predict(X))
            const confusionMatrix = [[0,0],[0,0]]
            Y_pred.forEach((y_i, i) => {
                if (y_i == Y_test[i]) {
                    if (y_i == 1) confusionMatrix[0][0]++ // true positive
                    else          confusionMatrix[1][1]++ // true negative
                } else {
                    if (y_i == 1) confusionMatrix[1][0]++ // false positive
                    else          confusionMatrix[0][1]++ // false negative
                }
            })
            return confusionMatrix
        }


        getEvaluationMetrics(confusionMatrix) {
            const [
                [TP, FN],
                [FP, TN]
            ] = confusionMatrix
            const [precision, recall] = [TP / (TP + FP), TP / (TP + FN)]
            return {
                accuracy: (TP + TN) / (TP + TN + FP + FN),
                precision: precision,
                recall: recall,
                F1_score: 2 * (precision * recall) / (precision + recall),
                specificity: TN / (TN + FP),
                MCC: (TP*TN - FP*FN) / ((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN))**0.5 // Matthews Correlation Coefficient
            }
        }

        /**
         * gamma adalah sebuah variabel sebagai constraint sehingga
         * a_r*y_r + a_s*y_s = gamma
         * karena : sum(a_i * y_i) = 0,
         * maka   : a_r*y_r + a_s*y_s = -sum(a_i * y_i ; i not in {r, s})
         *          a_r*y_r + a_s*y_s = gamma --> dijadikan variabel
         * @param {number} r index
         * @param {number} s index
         * @returns {number} value gamma
         */
        calcGamma(r, s) {
            let accumulator = 0
            for (let i=0; i<this.N; i++) {
                if (i === r || i === s) continue
                accumulator += this.alpha[i] * this.Y[i]
            }
            return -accumulator
        }

        /**
         * beta adalah sebuah variabel vektor, didefinisikan sbg:
         * beta = sum(a_i*y_i*x_i ; i not in {r, s})
         * mirip gamma, tapi vektor
         * @param {number} r index
         * @param {number} s index
         */
        calcBeta(r, s) {
            let accumulator = Array(this.P).fill(0)
            for (let i=0; i<this.N; i++) {
                if (i === r || i === s) continue
                accumulator = accumulator.map((acc_j, j) => acc_j + this.alpha[i] * this.Y[i] * this.X[i][j])
            }
            return accumulator
        }

        /**
         * calculate vector w based on alpha
         * @returns {number[]} weight w of the classifier
         */
        getWeight() {
            let accumulator = Array(this.P).fill(0)
            for (let i=0; i<this.N; i++) {
                accumulator = accumulator.map((acc_j, j) => acc_j + this.alpha[i] * this.Y[i] * this.X[i][j])
            }
            this.w = accumulator
            return this.w
        }

        /**
         * calculate bias b based on alpha
         * note: aku nggapaham rumus bias, jadi anggep aja gini
         * @returns {number} bias b of the classifier
         */
        getBias() {
            let n = 0
            let b = 0
            let w = this.getWeight()
            for (let i=0; i<this.N; i++) {
                if (this.alpha[i] === 0) continue 
                b += this.Y[i] - this.Math.dot(w, this.X[i])
                n++
            }
            this.b = b/n
            return this.b
        }


        Math = {
            /**
             * dot product vektor
             * note: belum ada param checking di function ini
             * @param {number[]} x 
             * @param {number[]} y 
             * @returns {number[]} hasil dot product vektor x dan y
             */
            dot: (x, y) => x.reduce((acc, x_i, i) => acc += x_i * y[i], 0),

            /**
             * operasi per elemen vektor 
             * 
             * @param {number[]} x vektor x
             * @param {number[]} y vektor y
             * @param {Function} callback function yg menerima parameter x_i, y_i, i
             *                   mereturn hasil operasi x_i dan y_i.
             *                   dimana x_i, y_i elemen ke-i vektor x dan y
             * @returns {number[]} result
             */
            eachElements: (x, y, callback) => x.map((x_i, i) => callback(x_i, y[i], i)),

            /**
             * 
             * @param {number[]} x 
             * @returns jumlah dari array
             */
            sum: x => x.reduce((a, b) => a + b, 0),

            /**
             * ambil 2 index unik random dari array dgn panjang n
             * @param {number} n panjang dari array
             * @returns {number[]} 2 index yg dipilih
             */
            pickTwo: n => {
                const r = [
                    Math.floor(Math.random(n) * n),
                    Math.floor(Math.random(n) * n)
                ]
                while(r[0] === r[1]) r[1] = Math.floor(Math.random(n) * n)
                return r
            }
        }

        }
    </script>
    <script>
        /**
         * DOCUMENTATION:
         * 
         * 
         * // 1.| deklarasi class
         * const chart = new Chart(e); // e -> html canvas element
         * 
         * // 2.| titik-titik datapoint disimpan dalam this.dataPoints : number[]
         * // modifikasi layaknya array biasa
         * p = [n1, n2, ..., nm]
         * chart.dataPoints = p
         * chart.dataPoints.push(n_new)
         * chart.dataPoints.shift()
         * 
         * // 3.| untuk  gambar chart berdasar this.dataPoints, gunakan this.drawChart(color)
         * // ini otomatis men clear isi chart sebelumnya
         * chart.drawChart("black")
         * 
         * // 4.| untuk clear chart
         * chart.clear()
         *  * 
         */

        class Chart
        {

            /**
             * 
             * @param {HTMLElement} canvasElement html element: <canvas>
             */
            constructor(canvasElement, padding=20) {
                this.canvas = canvasElement
                this.canvas.style.border = "1px solid black"
                this.canvas.setAttribute("width", `${this.canvas.offsetWidth}`)
                this.canvas.setAttribute("height", `${this.canvas.offsetHeight}`)
                this.padding = padding

                this.dataPoints = []

                this.ctx = this.canvas.getContext('2d')
            }

            drawChart(color="darkgray", withPoint=false) {

                if (this.dataPoints < 2) return

                // what the hell
                const drawPoint = withPoint
                ? (x, y) => this.ctx.fillRect(x-3, y-3, 7, 7)
                : () => {}

                // clear canvas
                this.clear()

                // get max & min X and Y
                // this.min_Y = this.dataPoints[0]
                // this.max_Y = this.dataPoints[0]
                this.min_Y = 0 // note: code di atas jika ingin Y dynamic
                this.max_Y = 1 //

                for (const p of this.dataPoints) {
                    if (p < this.min_Y)
                        this.min_Y = p
                    if (p > this.max_Y)
                        this.max_Y = p
                }
                
                this.len_Y = this.max_Y - this.min_Y

                // convert all this.dataPoints height to relative to canvas
                const Y = this.dataPoints.map(p => this.convertToVirtualHeight(p))

                // create gap within points
                const gap_x = this.canvas.offsetWidth / (Y.length - 1)
                let x_now = 0

                // begin
                this.ctx.beginPath()
                this.ctx.strokeStyle = color
                this.ctx.fillStyle = color
                this.ctx.moveTo(x_now, Y[0])
                for (let i = 1; i < Y.length; i++) {
                    x_now += gap_x
                    this.ctx.lineTo(x_now, Y[i])
                    drawPoint(x_now, Y[i])
                }
                this.ctx.stroke()

            }


            convertToVirtualHeight(p) {
                return this.canvas.offsetHeight - ((p - this.min_Y) * ((this.canvas.offsetHeight - 2*this.padding) / this.len_Y) + this.padding)
            }


            clear() {
                this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight)
            }

        }
    </script>
    <script>
        /**
         * NOTE:
         * karena semua angka pada train_x berupa bilangan desimal yang sangat kecil, maka operasi
         * komputasi SVM dapat menimbulkan banyak round-off & precision error (riil, udah aku coba).
         * maka dilakukan normalization / scaling kepada semua elemen feature vector X dengan faktor
         * 1024, yaitu 2^10 (dipilih eksponen 2 biar komputer enak ngitungnya)
         * 
         * sehingga bias dan weight yang nanti dihasilkan akan dibagi dengan faktor yang sama
         * (1024) untuk dapat melihat hasil aslinya.
         * 
         * hal tersebut mungkin dilakukan dan hasilnya tetap valid, berikut pembuktiannnya:
         * SVM's decision function:
         *  f(x) = sign(w.x + b)
         *       = sign((1024*w).(1024*x) + (1024*b))
         * data di scale: x_scaled <-- 1024 * x
         *       = sign(w'.x_scaled + b')
         * penggunaan decision function untuk data yang tidak di scale:
         *       = sign((w'/1024).(x_scaled/1024) + (b'/1024))
         *       = sign((w'/1024).x + (b'/1024))
         * terbukti weight dan bias cukup di scale down dengan faktor yang sama, dan
         * SVM masih bekerja.
        */
        const scale = 1024
        document.addEventListener("documentsHasBeenVectorized", event => {
            
            document.getElementById("svm-container").style.opacity = '1'

            // INISIASI SVM
            Data.scaledVectors = Data.vectors.map(vec => vec.map(ele => ele * scale))
            const svm = new SVM(Data.scaledVectors, Data.classes)
            let svmIteration = 0
            const metricHistory = {
                accuracy: [],
                precision: [],
                recall: [],
                F1_score: [],
                specificity: [],
                MCC: []
            }

            // ALL UPDATES WHEN SVM ITERATION OCCURS:
            {
                // VARIABLES INITIATION
                                
                // 1. CANVAS
                const svmCanvas = document.getElementById("svm-canvas")
                const canvas = new Canvas(svmCanvas, {
                    width: 400,
                    height: 400,
                    padding: 20
                })
                const selectX = document.getElementById("svm-x")
                const selectY = document.getElementById("svm-y")
                let select_innerHTML = ""
                Vectorizer.vocabulary.forEach((term, index) => {
                    select_innerHTML += `<option value="${index}">${term}</option>`
                })
                selectX.innerHTML = selectY.innerHTML = select_innerHTML
                const redrawCanvas = (axisX, axisY) => {
                    canvas.clear()
                    canvas.drawPoints(
                        Data.scaledVectors.map(p => [p[axisX], p[axisY]]),
                        Data.classes.map(c => c == 1 ? "blue" : "red")
                    )
                    const w = svm.getWeight()
                    console.log([w[axisX], w[axisY]])
                    canvas.drawLine([w[axisX], w[axisY]], svm.getBias())
                    canvas.drawAxis()
                }
                selectX.addEventListener("change", e => redrawCanvas(selectX.value, selectY.value))
                selectY.addEventListener("change", e => redrawCanvas(selectX.value, selectY.value))

                // 2. CHART
                const svmChart = document.getElementById("svm-chart")
                const chart = new Chart(svmChart)
                let selectedMetrics = "accuracy"
                const redrawChart = (metric) => {
                    chart.dataPoints = metricHistory[metric]
                    chart.drawChart("red", true)
                }
                document.getElementById("svm-metrics-form").addEventListener("change", event => {
                    // redraw chart
                    selectedMetrics = event.target.value
                    redrawChart(selectedMetrics)
                })

                // 2. HANDLE EVAL METRICS CHANGE
                document.getElementById("optimize-smo").addEventListener("click", event => {
                    const w_old = svm.w
                    const b_old = svm.b
                    const iter = svm.iterate()

                    // redraw title
                    document.getElementById("svm-iteration-n").innerText = `Iteration ${++svmIteration}`
                    document.getElementById("svm-selected-i-s").innerText = `selected {r, s} = {${iter.r}, ${iter.s}}`

                    // redraw table
                    const variables = ["ar-old", "ar-new", "as-old", "as-new", "w-old", "w-new", "b-old", "b-new"]
                    const values = [
                        iter.a_r_old.toFixed(7),
                        iter.a_r_new.toFixed(7),
                        iter.a_s_old.toFixed(7),
                        iter.a_s_new.toFixed(7),
                        w_old.map(e => (e/scale).toFixed(7)).join(",\n"),
                        svm.getWeight().map(e => (e/scale).toFixed(7)).join(",\n"),
                        (b_old/scale).toFixed(7),
                        (svm.getBias()/scale).toFixed(7)
                    ]
                    variables.forEach((varName, index) => {
                        document.getElementById(`svm-iter-${varName}`).innerText = values[index]
                    })

                    // redraw canvas
                    redrawCanvas(selectX.value, selectY.value)

                    // give accuracy info
                    const confMatrix = svm.getConfusionMatrix(Data.scaledVectors, Data.classes)
                    document.getElementById("svm-conf-tp").innerText = confMatrix[0][0].toString()
                    document.getElementById("svm-conf-tn").innerText = confMatrix[1][1].toString()
                    document.getElementById("svm-conf-fp").innerText = confMatrix[1][0].toString()
                    document.getElementById("svm-conf-fn").innerText = confMatrix[0][1].toString()

                    const evalMetrics = svm.getEvaluationMetrics(confMatrix)
                    for (const metric in evalMetrics) {
                        document.getElementById(`svm-metrics-${metric}`).innerText = evalMetrics[metric].toFixed(3)
                        metricHistory[metric].push(evalMetrics[metric])
                    }

                    // redraw chart
                    redrawChart(selectedMetrics)

                })
            }


            // PREDICT MODEL
            document.getElementById("predict-model-button").addEventListener("click", event => {

                // table
                const table = document.getElementById("predict-model-table")
                table.innerHTML = 
                        `<tr>
                            <td colspan="4">as vector</td>
                            <td colspan="6">SVM</td>
                        </tr>
                        <tr>
                            <th>Vocab</th>
                            <th>TF</th>
                            <th>IDF</th>
                            <th>x</th>
                            <th>w</th>
                            <th colspan="2">x‚Ä¢w</th>
                            <th>b</th>
                            <th>x‚Ä¢w + b</th>
                            <th>sign(x‚Ä¢w + b)</th>
                        </tr>`

                // as vector
                const doc = new TFIDF_Document(document.getElementById("predict-model-textarea").value.trim().split(" "))
                const tf = doc.calculateTF(Vectorizer.vocabulary).map(e => e.toFixed(7))
                const idf = Vectorizer.idf.map(e => e.toFixed(7))
                const x = Vectorizer.vectorizeDocument(doc).map(e => e.toFixed(7))
                
                // svm
                const w = svm.getWeight().map(e => e / scale).map(e => e.toFixed(7))
                const b = (svm.getBias() / scale)
                const x_dot_w = svm.Math.dot(x, w)
                const bjir = x_dot_w + b
                const pred = bjir > 0 ? 1 : -1

                for (let i = 0; i < svm.P; i++) {
                    const tr = document.createElement("tr")
                    let tr_innerHTML = `<td>"${Vectorizer.vocabulary[i]}"</td><td>${tf[i]}</td><td>${idf[i]}</td><td>${x[i]}</td><td>${w[i]}</td><td>${(x[i]*w[i]).toFixed(7)}</td>`
                    if (i == 0) {
                        tr_innerHTML += `<td rowspan="${svm.P}">${x_dot_w.toFixed(7)}</td><td rowspan="${svm.P}">${b.toFixed(7)}</td><td rowspan="${svm.P}">${bjir.toFixed(7)}</td><td rowspan="${svm.P}">${pred}</td>`
                    }
                    tr.innerHTML = tr_innerHTML
                    table.appendChild(tr)
                }

            })

        })    
    </script>
</body>
</html>